import os
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from ta.momentum import RSIIndicator, StochasticOscillator
from ta.trend import MACD, EMAIndicator
from ta.volatility import BollingerBands
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
from sklearn.preprocessing import label_binarize
from xgboost import XGBClassifier
output_dir = "wyniki_wykresy"
os.makedirs(output_dir, exist_ok=True)
def generuj_wykresy(horizon, threshold, model, X_test, y_test, feature_names, df_corr):
    base_name = f"h{horizon}_t{threshold:.4f}"
    importances = model.feature_importances_
    feature_importance = pd.Series(importances, index=feature_names).sort_values(ascending=False)
    plt.figure(figsize=(8, 6))
    sns.barplot(x=feature_importance.values, y=feature_importance.index)
    plt.title(f"Ważność cech – horyzont {horizon} dni, próg {threshold}")
    plt.tight_layout()
    plt.show()
    y_pred = model.predict(X_test)
    y_test_decoded = y_test.replace({0: -1, 1: 0, 2: 1})
    y_pred_decoded = pd.Series(y_pred).replace({0: -1, 1: 0, 2: 1})
    cm = confusion_matrix(y_test_decoded, y_pred_decoded)
    plt.figure(figsize=(5, 4))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=[-1, 0, 1], yticklabels=[-1, 0, 1])
    plt.title(f"Macierz pomyłek – horyzont {horizon}, próg {threshold}")
    plt.tight_layout()
    plt.show()
    y_prob = model.predict_proba(X_test)
    y_bin = label_binarize(y_test, classes=[0, 1, 2])
    plt.figure(figsize=(6, 5))
    for i in range(3):
        fpr, tpr, _ = roc_curve(y_bin[:, i], y_prob[:, i])
        roc_auc = auc(fpr, tpr)
        plt.plot(fpr, tpr, label=f"Klasa {i} (AUC = {roc_auc:.2f})")
    plt.plot([0, 1], [0, 1], 'k--')
    plt.title(f"ROC – horyzont {horizon}, próg {threshold}")
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    plt.figure(figsize=(10, 8))
    sns.heatmap(df_corr, cmap='coolwarm', center=0)
    plt.title(f"Korelacje między cechami – horyzont {horizon}, próg {threshold}")
    plt.tight_layout()
    plt.show()
selected_combinations = {
    (10, 0.0275), (10, 0.0525), (10, 0.07),
    (20, 0.0425), (20, 0.075), (20, 0.105),
    (30, 0.05), (30, 0.095), (30, 0.125)
}
df = yf.download("TSLA", start="2021-01-01", end="2024-12-31")
df.reset_index(inplace=True)
df = df[['Date', 'Open', 'High', 'Low', 'Close', 'Volume']].copy()
df.dropna(inplace=True)
sentiment = pd.read_csv("C:/Users/Micron/Desktop/danetesla/dzienny_czyszczony_finbert_wartoscmax.csv")
sentiment["Date"] = pd.to_datetime(sentiment["date"])
weights = [0.5, 0.3, 0.2]
sentiment["sentiment_score_wavg"] = sentiment["sentiment_score"].rolling(3).apply(
    lambda x: (x * weights).sum(), raw=True).fillna(0)
sentiment["sentiment_norm"] = (
    sentiment["sentiment_score_wavg"] - sentiment["sentiment_score_wavg"].mean()
) / sentiment["sentiment_score_wavg"].std(ddof=0)
df["sentiment_score_wavg"] = df["Date"].map(dict(zip(sentiment["Date"], sentiment["sentiment_score_wavg"]))).fillna(0)
df["sentiment_norm"] = df["Date"].map(dict(zip(sentiment["Date"], sentiment["sentiment_norm"]))).fillna(0)
df["news_count"] = df["Date"].map(dict(zip(sentiment["Date"], sentiment.get("news_count", pd.Series(0))))).fillna(0)
nasdaq100 = yf.download("^NDX", start="2021-01-01", end="2024-12-31")
nasdaq100["nasdaq_return100"] = nasdaq100["Close"].pct_change()
nasdaq100_map = dict(zip(nasdaq100.index.date, nasdaq100["nasdaq_return100"]))
df["nasdaq_return100"] = df["Date"].dt.date.map(nasdaq100_map).fillna(0)
df["nasdaq_return100_roll3"] = df["nasdaq_return100"].rolling(window=3).mean()
close = df["Close"].squeeze()
high = df["High"].squeeze()
low = df["Low"].squeeze()
df["rsi"] = RSIIndicator(close=close, window=14).rsi()
df["macd"] = MACD(close=close).macd()
df["ema_10"] = EMAIndicator(close=close, window=10).ema_indicator()
df["ema_50"] = EMAIndicator(close=close, window=50).ema_indicator()
df["stoch"] = StochasticOscillator(high=high, low=low, close=close).stoch()
bb = BollingerBands(close=close)
df["bb_bbm"] = bb.bollinger_mavg()
df["bb_bbh"] = bb.bollinger_hband()
df["bb_bbl"] = bb.bollinger_lband()
for col in ["rsi", "macd", "ema_10", "ema_50", "stoch"]:
    df[f"{col}_roll3"] = df[col].rolling(3).mean()
df["daily_range"] = df["High"] - df["Low"]
df["range_pct"] = (df["High"] - df["Low"]) / df["Open"]
df["return_1d"] = df["Close"].pct_change(1)
df["return_3d"] = df["Close"].pct_change(3)
df["return_5d"] = df["Close"].pct_change(5)
df.dropna(inplace=True)
horizons = [10, 20, 30]
thresholds = sorted(set([t for h, t in selected_combinations if h in horizons]))
for horizon in horizons:
    df[f"return_{horizon}d_future"] = (df["Close"].shift(-horizon) - df["Close"]) / df["Close"]
    for threshold in thresholds:
        if (horizon, threshold) not in selected_combinations:
            continue
        df["decision"] = df[f"return_{horizon}d_future"].apply(
            lambda x: 1 if x > threshold else (-1 if x < -threshold else 0))
        df_model = df.dropna()
        features = [
            "rsi", "macd", "ema_10", "ema_50", "stoch",
            "rsi_roll3", "macd_roll3", "ema_10_roll3", "ema_50_roll3", "stoch_roll3",
            "bb_bbm", "bb_bbh", "bb_bbl",
            "daily_range", "range_pct",
            "return_1d", "return_3d", "return_5d",
            "sentiment_score_wavg",
            "nasdaq_return100", "nasdaq_return100_roll3"
        ]
        X = df_model[features].apply(pd.to_numeric, errors='coerce')
        y = df_model["decision"].replace({-1: 0, 0: 1, 1: 2})
        X.dropna(inplace=True)
        y = y.loc[X.index]
        X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, test_size=0.2, random_state=42)
        model = XGBClassifier(objective='multi:softprob', num_class=3, use_label_encoder=False,
                              eval_metric='mlogloss', random_state=42)
        model.fit(X_train, y_train)
        print(f"\n=== HORYZONT: {horizon} dni | THRESHOLD: ±{threshold} ===")
        print(classification_report(y_test.replace({0: -1, 1: 0, 2: 1}),
                                    pd.Series(model.predict(X_test)).replace({0: -1, 1: 0, 2: 1}),
                                    zero_division=0))
        generuj_wykresy(horizon, threshold, model, X_test, y_test, features, X.corr())